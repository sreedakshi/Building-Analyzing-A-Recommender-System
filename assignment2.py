# -*- coding: utf-8 -*-
"""Assignment2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CVopI5jwYQC7ZXYgc1dZebpuLMh3sFVc

# Assignment 2 - Optimization Exercise (Due Nov 16 at 6:30pm):

* In this assignment, you're going to use the Surprise framework (https://surprise.readthedocs.io/en/stable/index.html, a Python scikit for building and analyzing recommender systems that deal with explicit rating data) within iPynb to :

  (a) run a set of built-in recommender algorithms on a dataset and compute certain statistics

  (b) implement two metrics to evaluate prediction/recommendation sets from those algorithms: ndcg and ILS (intra-list similarity)

  (c) implement a gradient-descent latent-factor algorithm (Funk-svd) and use your metrics to compare it with the pre-built-in algoroithms.

  For each of these, we'll provide you with stub code into which you can build the solutions.



* To start this assignment, **make a copy of this notebook** by clicking File --> save a copy in Drive like below.

  Then please **work on your copy**.

  ![Screenshot from 2021-10-07 23-31-19.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATwAAAFLCAYAAABLIjB/AAAAiXpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjaVY5dDgIxCITfOYVHoEAHOI42u4k38PjStLr6PcBkws/Q8XqedJs0FrLugQS4sLSUe4nghTI34TZ71cXu2krJZZPKEshwtmvQtv+hKwKnmzs6BobUdTlUNKrWHs2rPGPkz7exlf779vgGWCneTXMsg/sp+6gAAAoGaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIKICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICBleGlmOlBpeGVsWERpbWVuc2lvbj0iMzE2IgogICBleGlmOlBpeGVsWURpbWVuc2lvbj0iMzMxIgogICB0aWZmOkltYWdlV2lkdGg9IjMxNiIKICAgdGlmZjpJbWFnZUhlaWdodD0iMzMxIgogICB0aWZmOk9yaWVudGF0aW9uPSIxIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz7eZquyAAAABHNCSVQICAgIfAhkiAAAIABJREFUeNrs3X9sW+ed5/t32linN6hPOh0dTAMf5PaSY+wxcQuaA1yawJbiZkBxi0qcH6KADWUgl/IMQrkzQxUFyC4W5N5tKdybUkBupOlCUrCVhAKi5g9a2xnK3bmU0AztXFxaQEoLs6A1SKiZyRwjBY5nMzkpUh85ju4f1E9b8o9EdmX7+wIEGeKP8/A5z/nw+5xD82Fd3O7/+7/WT/3Wb63//tTf7/77e/91/X//n1l/9vdn19+XXvr0/uu/W1f4V+vfrUtXfDpvrCd/i/XfSr5xj/f/+/X/+5Sy/uy/nVp/7wnvuacRtwv8AQnjNc72n+TkT17kG4Gv8qVfXOYnf/ETLvFvGXvlRb70xHbOdf7lX67f8R5f+NKX+IKMosOj9hrjl7/EN/7iD/jKE94VEnh7Mhj46xpf+U//nld+8hNe++t/gS99lcC/+U/8t1e+zTe++gR3zd98m5MvTPCP+97hWf7df/sX/uIbMooOh3/hJ+N/wd995Q8Y/8aXnvjeeGp9fX1dBoW49+PnH6it/APX9yvyvvAFvmIEMOTYEhJ4QghxyKa0mxn4687Cp556atdvIYQ4sMBbX1+/7efXHXi3/gghxGcOvPX1dT755BM++eQT/uEf/uFQNfKrX/0qn/vc5/jc5z4noSeEOLjAu3nzJgDHjx8/FA18++23t9okVZ4Q4rP43M6p7CeffMLHH3986Br58ccf88knnxyKabYQ4hEPvJ0V3mEPPCGEOJAKbzP0Dpud1Z2EnhDiM1d4O6u8wxp4QghxoIF3WEngCSEONPDuTYNC2IXLdeuPQbICNMbo8seZMQEcykkDf7b2AF/Cfu1xEZ+x9nxENeXFSFU2Hr6zvQelTjboIphv3H6TOUmPy0uq4mDOxPF3FWgciqFgMRM3CGbrj/aItmaI7xoHXvxdScaq1gPaoE0l5SeYreEclj5oFAi79j4mXK59xuV9qZL2bhzvD3I/GkHy9T3Gac+9jtPb8+dTfnlAG67+CSb69B1/U1B1wAnQ36/j0R7mHt6rPaBq99AIfXd7a2k/CTvH8kQU5VO3x0cscoxidZ5GzoNnZ95V5mkcDTEQUtDMPvoVHV3eeHHKSbx5jemlIQKfeTi0ExueZcADOBb1YoF8MsGHc+fJeA7iDbaHev9FZk9rgIqne4B+xf0ZxssB8wwwvRDbCOAa+a485M6T2+hYRXtyR9yn/rYUpV3H7XbvcYOP3rO+h/5C9m3P3agPpr2+7gjHpirMNzJ4tg4yk8p8AyU0QEgBxR3lrBtx8KMBVXfTGg5u3EPDWPUuiufqZDwHv6/1yBnOHKrXr6K71a0xpwKOttkfMqU9+HLaiLPPbBKrOkYy7McwDPxdKWYa9gN/kXZtjETYi2F4CSbyLFh7tbdK2uui79w11hYGOeFKUPosTfN1Ezm2SmV+x/TBrDLfUAh1h1AAc7IHo2uM5laZ06CU7iHoNTC8YRL5CiaAVSJuhCls3bFG1m8QL1lb06pywiCYP8DpaDWF159iciZNj9/AZfjpSpfZnvmbVPIJwl4Dl+ElnCiwa9ZoVsjHw3gNA2+wh2y52ao47BIJI0ginSTsNQjnL1NOGpwYXGDtWpE+l5dU9aBHQOtgt0wLhyZjXQY9kzvOYdTS+I0kla32hcnOjJHs8mO4DILxfOu1NQqEXd2Mr65xKXcKV9ck5q3TpmoKrz9JYSxJ2G9gGH56shWazTLZniCGYeANJhir7Rhc++33B3tUUJ9M0eU3WsdFPEu56dzH7bvO09x5LDxo+421W0805YMPIPDuEoaJ1DzqwATnF+cYCjQpJPJUH+TJD6tMOjmC6csxe36W4W6bWv3DPe4YYnjpMlOxdto6R7h8ZYJe9TPVeHRHjrFamd8KNKs6T0MJ0R1S9jyHVk4lKFidDM0tcn6iH6WSIjVpguajw21Sr22MosYCtWtr1Bdq2BvTrAsNlUCH52D77lqFqQsnGJw+z/xoBMpZCpXWzjJn0qTKCv3Ti1w4P0rEmSGZmsFqvcOQjaepezLMLp5netBNLZ1kZDP7165Sb+oMTs8xPXCC6OgylwsdtLXHmLq8xGjo4M9PWhaomnqP085VSlNX6MhNc/7cED5zivRIHTwZzl8+R7+rjZPZC1yZO7P36YhrVapXuxmePc/sUAi7lKIrPgX9o5w/P03G02Q4PbJx7vYO+/0Bak4miI9bdA+fZ3FxmkGtRjqRpWrf2+278uZOY+HBVzN3HmsHU+GtcWW4c9cFC2/6bm/LDpXxGexojqFeH27dQySTIUKFc7XPmni3tseFEZ/BBKxKkarSy9BQLz63h0DvEJnI0X1mQtsHhKJ89jMyvu4Ix1arVJqtgV2Zr6OEYuyZd80S41U3g8NnCbl13IHT5Po9NOYrmLgJBXQaF+o4QLNaw+noxF1foOYAjQvUHR8dvgM+i9QWIjN8hpDHjScyQMzj0Ljcim9r1QS9g4hPR3eHyAyPkou15kxWZZySOsBwLoJHd+PrzTEYMimfq2+dY4tmckR9HnRNAUXZ6G8FRT3oM2E2jVKWkbpGNHav09l2okPDnA54cPt6GYi6sJsNLEBRFZSN8bHvEGmLMJiL4nO78fUO0ucBNZJhKOrD7Q5weiDCMatJw77bfn9QakyNN/ANjnI25EbXffQOD9HrlJmqWPdw+y1vJ3cYC5/tsL7KVOzWiy6nyF1e29723cbawZzDu/0igaLe7USoSbP5IVevJPCWdrymtTVOWQ58plO+e1y0UDV0oH6lCZ4YHmX7/M5DO7ns6yZybIb5SpOzvTXm6wqhicCe23eal2muXSIfNMjvCPI1zYMF+Dp9KOkLNBwP9QWbwOAgrkKChZqDz6xjeroJqAfcfkVBVXecF1PA2Xhv8vUNEqpkCYfnCYU66Y5FOd3buvJTu9xg7UqNLmNk546Gbmt7HzzInbBxoExtDQ8X3UPTZO75DUFB3dFA5Wjrhd/z23Irw3e9VlVVd/WrgoPj3H2/P5DLC1aThq0T8Gm7zr2f8kHlchNCd7m995Zhfoex8NnecHdcfNpRrZ9LJShv1gl3HWsP+qLFHSq8D502TgxM33Y1VdE++5G6f3uUhxtyt01rNWbmK9TUC9SVEBMBZb/ugaOdDM3l2H0XFQ3A14nPHqFWr3LJ9NEX8KCHVIoLNWp2A3fHEA/1wri7l4nFEI1qleqFeQrxEUZ6J5jduBTYdirD3HAEdfeOhq2h+gDtPFAa4yTSDU74DtFV1PvZ7w+IsldDnHu//V7HgvoZW7l98Wm7X47d0rj9x9rDuGixL50TbjCbFqquo2/8aJqG9gBHon5CB/PK9oWBhx153RG0K0Wy43XUSIz98k5xu9GdJqvOdt/ouoa2ed5J8dHpaTI/co6Gr5OAAp7OENTGKdZVAoGHeQnOpjZTYKau4In0cnZomrnhEObMFDVno8+bV7C1Ha9F09C0hxU5mweKG3c0QyZkMp4vbZxTalVcjrN99Dp3OJYfeEvvtt8fBM2NWzVpNHZUQU6DSw1wn3Df/fb7GAsPPFXuc6w9xMBTifT3olbzJMcqNEyTRqVAIpw4kA/9OtcsTNPc9WPZoEX6CFkz5MfqWI6DVRtjvPrh/q1UFWheotY0sQ8m8Ygcu8rqVZVQd2D/Qezpo99nMZlKU6o3MZs1ZlJddOU3P9CqEeh0c+VSA3fnxjunp5OAfYlLdoCDvl5x1/rgSpl8Nttqq1mnutDA0XV0BfTIABHKpFOTVJsmZr1MtidMqrJ/jyqqimI3qNeaWAd64V4jmhnEXStQqNqAhset0jw3TrnRpFErkS2U+fA+xnG7CualGg3T+uxBedf9/iAE6B/wUCukGau29l8pm6VElIGodg+33/tYeOCBd59j7aFepVUCQ8yORlHOpenpCBMv1PFkhuj9zCcq1lid6qOjo2PXT2KmCVqU4YkBlHMJTp3w0lNYxe1r3zd4PH0DBJwSyZ4slQO5zNS6Wkt7iO6AcscK+PRE6wpeId5JR1eKIn0MZ7ZDUg8EcLV56AxoW+dVugNHaQt04FMebuAFctMMBSxGEl10dCQoNH0MjWZaH7LWIgzPDhGyp0h1dRBOjmCGhhiK3GGCE+hjwGcykuihUD/gQ919mlyvQrkwTgOFQGaY02qVdHcn8fQ5lECI9vuYqUT7oyjVND2p8gFcWLj7fn8gZyTOTDDdrzCf7qIjnGDcDLX2mXpvt9/zWHjQ7nOsPbW+vr6++cWfjuNw/fp13n///UP1BaC/8Ru/wRe+8AUUReHzn/88n/vc5xBCiPvx8D+HJ4QQv0YSeEIICTwhhHic+HIXJfCEEFLhCSHEY2fX/7TYXALxMK0fsblW7ubXz8syjUKIAwm8nSFzWNaA3Rl2m+vTyte9CyE+deDdWtl9/vOfPzwNfPppbNvGtm3ZW0KIg63wDtuU8bB8AFoI8eiTixZCiCenwnv77bdZX1/n5s2bfPzxx6ytre3+7i4hhHhcAu/48eNbFwRu3LjB9evX+ed//mfpGSHE4z2l3bwaKoQQT0TgCSHEExF4QgghgSeEEBJ4QgghgSeEEBJ4QgghgSeEEBJ4QgghgSeEEBJ4QghxyAOvRtbvJVV9eFu06yXGyo37X+G9liUYzFK7rwc5lJMGLpcLl8uF4fXTlchTatzhe/7sMkl/F4WGDFQhDjzwXn31VUzTfGJevF0vMlJscN9fLeobYHi4H9+n2Oax/nNcWV1l+eIcuQ6TkXiCsf0CTQ2RGR2izy0DVYgDD7y3336bX/3qV4eyoU6zTDYexGsYeIM9pGd2VmYW1UKSsN/AMPx0JSepb6aYVaWQCOM3DAxvmMRYDRuHSspPV+Eya5eyhP0pKg6ATX0yRdfG8/SkSzT3Kv/qI6RSU9QBp5zA6Moylu7Bb7gw/F1kK3d+01AARdUJnBlltNdifKSMvflcwQTJHj+GN03VqVJIpCk2wS4l8HaN0dx6ySUS3i7GmvfRbiEk8B4BTo18IkvDN8zi8goXJ2JYIwnSlVaqNSeTpCoaufPLrCzN0s84yXwVB5OZVIqKnuP8ygrLszHskTSFukJkdInzmZO0nRpicWmUiAJWKUVyCgbmlllZmqDTzJMcuYf55JUqVzqGWVy+zNyASjk7Tv2eXpiCryOAUr+wfX/LQh+cY2lpmNDOYi8SI2DOU9lIPLs6T90dI+r+DO0WQgLvEOZdtUjZiZLJBNAUUD2nyfVrVIoVbJpUzjXwDWQIaQqobnpzwwyeUnHQiAzPMZsLoQGKJ0Kn28Js7jWJNSkXa7gHckR1BVQfZ/pDWNXqdlW1nxN9DEbdqIqKJ9SBbps073WerKootr1drbq76QvpqMrt09tYyGK+0gRsqvN13LEI+mdptxBPmKfPnDmza0nGP//zP+d73/veoWqkbVk4+kn0HX/TdQ3mLSwsrloqmrbjW5r1EKd7Nx5r1ylk09SaFg5gW+xz7s1i1VrjUu4UrtyOP7erWMADO41m2ziKinL3ZCQUC5AtVGie1pmve4gN60D919NuIR7FwMtkMlvfeFwoFPjDP/zDQ9dIVdNQrFUs2Ao907RA09DQOKbZXLJtYCP07Cb1poLHZ1JIFLAys5zvdaPQZKyri0v7BMox9SidmYtMRB/WV9w71BZqOL5BPPcyAQ7ECFkFiuM6dV+MIe3X1W4hHtEprWEYbP60Kif90DVSCfURpUxhsnVF1WmWKExZRPoiqLiJdHuoj49QswDHpJxNkJxq4Dg21sZc0bEtGpUi8zvmeYqqgL26cR83kZib2kiectMBHMxKgezMp/jYyj1Vdk2qk0nSZZXTg1G0e+qIALGIxcxkDU93ZOMxD7ndQjzKgXe4mvMh8/2urc+quVwujGQZRwmQm87hXkgSNAz8iSLq4DRDkVZF4z47ynCgSTZsYPh7GGeA6aEIqhIhMxTCKnTh93eRnm8nENBxbAsALdRHxJ6kx5+kbIP7zASjEZuRuBfD8BMftzgZcN/DdPPeXZ2KtV5XME7hgs7A9CwZ371uQSEQi6IpAWKR7WruYbRbiMfBU+vr6+ubU9ozZ87wrW99i/b2dlkPVgjxeAee4zhcv36d999/XwJPCCFTWiGEkMATQggJPCGEkMATQggJPCGEkMATQggJPCGEkMATQggJPCGEBJ4QQkjgCSGEBJ4QQjwinn777be3vgB0bW0Nx3H48pe/LD0jhHj8Au/48ePs9W0pQgghU1ohhJDAE3uzmOkxiM9Yj9fLssskjM11cR+eRj6MkazIsBKPQ+DZ1GfSxINeDMPAH46TLbXWsXhoB1ShC3+y/FC3KYR4AgOvMZYgMWLROTzHxaWLzOY6MAtxkjPmQ2uDu2+I0UwIWf9LCAm8B8epMD5uEhoa5UzAjaZquENnGc0FaIyMUwMwJ+kxukim44SDfrzeMImx2nY15jQopXsIeg0Mf5jkZL11mzlJjxEnP5aiy2/gMoLEC9U9q7hmMU2iUMUBnHICoyvLWLoHv+HC8HeRrewRvndr1+47U87GW200/HSlZmg4QKNA2IizPfOtkfV7SVZscJqU0z34jdYiRelskmAwS22zjcEEyR4/hjdNFXCaZbLxIF7DwBvsIb1jBbNKyks439iecM/EMXpmsO76eh0aM63+M7xB4vl59pukV1Negsks6R4/hsvA35WmVK8ylgzjNVwYwR7y1e1HW9UCibC/VdV3JZms7+g5q0p+47X4u5JM7Vrh3KY+udEmw09PukRTlmoTj0TgNS/RcDx0BnbXVmqgA49dp7GVMxZ0DLN4cYmluX6YSpGvOoBNNZ2gYMWYuLjC0mw/jCc3bgPW6tSudjNxcZnLsxHsyQIz93L+6UqVKx3DLC5fZm5ApZwdp77nHfdr161T5iTZho/RiyusLI3ia+RJTzbB001ErzNf2QiC+jxVJ0AsoNKcTJGuucktLrO8OMQpu8HVnU9tWeiDcywtDRNyauQTWRq+YRaXV7g4EcMaSZCu3OMkfb/XWy+QzDcJDC+yvDRH5oSDubb/01xtOnSOXmTl8nkGtQqZeIGrsWmWli8z1wczm8/bGCORqqBn5lheWWZ2QGEqkaJktvq0lE5RVgeYXVpmcSIG5vbrsEopklMwMLfMytIEnWae5EhDjmrxCASe7WArKsqtc0lFRcHh2tY4d9MZaq2dq7hPMxCB6nwd7ApTFY3+3Gk8Kqju0wxEFKoLG/HU5qN/MIKuKKi+bnyayeq9zJRP9DEYdaMqKp5QB7pt0twzO/Zp16336h/l/MQgPhVQA3QHVMwrJuAhFnNTn69gAY35KnYgRkA1qc438Q1kiOoKiuqhty9A+64n7aYvpKMq4FSLlJ0omUwATQHVc5pcv0alWLm385L7vN76fAU7NMBgSEdRNHy9MXxt+z/NsUAfEV0BtbVucJu7m4GIjqKoeCKd6JaJ6UD9XBEzkCEX0VFQcEdzDHpqFCsm2FXmaxq9g6fxqAqqHqE/pG9XysUa7oEcUV0B1ceZ/hBWtUpTjmuxj6cPTUtUBdWxcWzYdQLNsXFQOLrPSTXtmIp92cKxLKy1Kwx3uhjecXtbp729IPWOhVoVeKAXJrbahXt3fis21XySYr2J7YBjX4PQRm5FunGPzFMxfVyt2oQyAVSaXLUVNO2elurGtiwc/SQ7l1PXdQ3mLT7LdWLbslF1/VOd21RQQFFu+dtGlWZaaLq+Y9doaLqKtWqBbWOj49L3rqhXrTUu5U7hyu34c7uKBbf0uhCHLfDcp/AoZRbqDtHQ9vC3axdoqD4GdeC2iszBXLVRVQ1FdVDbTpJdnOOMfvs5tod8QnK7Xbtjg0o6wbg6zOz5CLoC9WyQxGbyuiN0u0c4NzKFY4UYDKmAxjHNoWFZwN1DT9U0FGsVC7ZCzzQt0DS0jS50uP8TXaqmYlutN4+DXOBb0zUsy8TBs/G8FqZpo3ZooKqo2Ni3vgm2WsQx9SidmYtMROUSk3jUprRKhIEBjWo2xUzNxHZszNokqXwNz0A/ge2TfcyXWx9VseuTjFQg1O0DLUQs0GQqX6JhA45FbTLLWO1hfcBkn3bdEoSW7WxVrma9RLFm7QggN9GYh8a5c5ihblq5rxPq9lCfKlAxHbCblIo1ru3XjaE+opQpTLba4jRLFKYsIn0RVEA/oWPV5qnbDo5VY2q+wdo9vDpfdwStOk5p46qAWV2gsfbZe80Xi6JXRyjUrNYbRaXAVMNHX1QHNUR3oElxvNqqTu0683Vzq68iMTe1kTzlprP12OyOCzRCHN7AAzxnZ5nuV5lPd+H3+unKLqANTjNxxr3rnV25nKfLa+BPnEMdGCUXUgCN3tFp+pUpEn4Dw99F/rKLgOdhvfvv165d9Qy9uRy+RpqwP0g8fwkt4EN37K3pph7pxtN2lFB3aKuScp8ZZdjXJBs+gRFOcQGNo/u+cQTITedwLyQJGgb+RBF1cJqhSKsf3KdznFErxE+ewN8zgqXptN1TMmUYzWgU4378wTCpBQft6EHs9AwTwwGa2XDrSuuITWxigtP6Rn8NjxJqZgn7gwTjI5jqdpXrPjPBaMRmJO7FMPzExy1OBtwHWoGKx8tT6+vr63v9X9rjx48fvtaak/SEF+hbmqVXfUzbZZVIdF2g7+IokX2OXKecxD/iZnYxg0fGsBCPZoX3xLNNqiPjNEN97CwO7UqKnnS59Rkzu87IVA010CEn5oW4T09LFxwWVdLhJFX9NMMTgV3TMjUwQGwhS8KfxkLFE8owkQvI1E2Ix3pKK4QQBzWlXV9fZ319XXpFCPF4Bt5myEnQCSGemApPgk8I8cRUeDKlFUI8ERXezupOAk8I8dhXeJs/n3zyifSKEOLxDrybN2/yySefSOAJIR7fwNsMuY8//pgbN25w48YN6RUhxOMZeB9//DHr6+t8/vOf5+mnn+bIkSPSK0KIxzPwpKITQjwxgec48u1hQognw9OO4/DFL37xthuuXbsmvSOEeLwC7/r163ve0N7eLr0jhHi8prRyDk8I8cQE3s2bN6UXhBASeEII8VgFnnSBEOKJCTz5sgAhhASeEELIlFYIISTwhBBCAk8IISTwhBBCAk8IISTwhBBCAk8IISTwDgGnnMDoGqN50E9sTtJjxCnZ0sdCPGKBVyPrd+FPVdh1/NplEkaYQuOwdZ1JdXKSqimDSAgJvE/p2nyWbOVRKFmazI9PsWDJIBJCAu9TaeNkh041m2XfzHMalNI9BL0Ghj9McrKODdjlJN4d08ZGIYwRn2Ezj2pZP8Fs7ZYna1AI+0kWCiTCXgzDSzAxSX3zW+/tBjOb2/IGiWfLNB2gMUaPN0n52lVKcS89Y62tOmaFfDyI1zDwhhMUqjvS0L7MVLILv2FgBOPkKztv22c7rRupTSbp8hsYhpdwokB1z5C1qKTD+HvGaMi39gvxKASegt43TMZdJZu9ZWq7cfBX0wkKVoyJiysszfbDeJJ81UENdOIzL1CzWtVXtWpCY2EjHJpcqEOg07dXTUmtfpSB2SWWLw4TaBYolCzAppJNMGJ1M3pxhZXFYXyNLIlCHcdzlrnlCaLtx+idXWburBucOoVEmkbHKIsry5wfVCmnspQ3w8lqQmyCxeWl1m3pNCWLO28HMGeSJKcU+meXWFk+T06vkkrccj7QsanlE6QbIUanz+JRZGAL8UhMaVHcnB7O4KnuMbW1K0xVNPpzp/GooLpPMxBRqC7UQQvQ4W5woWaDWWWBXs4EGsxXbbBq1E0fHb69kuAoof6zBDQFRYvQ6VMwV02wKxQrGv25M/hUQAuQyUWhVKS2RwXl1IqU7CiDZ31oKOjRQfr0GvOb5aI7Rn9ER1VU3L0ZerUa8zX7LttpUi7W8Qzk6HWroOiEcoOEzCLF+taWuTyeJFlxMzydI6DKoBZiP08fylbppxnKLdCVzVKZ69gxa7Ow1q4w3OlieOdEuNPGQSfUqTN+oY5pL2AHMgyctAjPVzGVCzR9nYTuJwwsCwsNXd/xN82F5ixgOcAt2elYJh9eu0Sfq7hrin7KsuG27aq4NKhZ9l22Y3HVUtB1bccbgo6u2ZgWoAFrlynOtNGmhpCZrBCPYuABeu8QufkuslmbrcNd1VDbTpJdnOOMfvtj3KEA6rl5RkyLQMaH6u7Gl59nXGng7sxxX8WPpqFhYZqAezMEV7EUDW2PQlFRNY66BphdzOC5tfor35amrFqgaupdtqNxTHO4YG2mG+CYmJaKttkpbS76Z6c5NdVDOjWDb/Y0uoxrIR6RKe125NE7lMNTv8CVtc0QChELNJnKl2jYgGNRm8wyVtuY+no6CdjnONf00e0B1BCdnhrFikpH4D5jQA0RC1lMFUqtCwh2nbFCGaJ9BJRWlaYoNpbZ2rYSiBGxS+TH6q0LJXadmXyBrWsTzXOMV0xsx6ZZGqFkBegOqHfZjpton4/GeIGK6QAW1cIIVb2P2NbpSI0Tbp3I0ChRq0BqrCGVnhCPXuABei9DuQ6Obpdd9I5O069MkfAbGP4u8pddBDybtZuPzsBR2kPd+DZCKdTto00PEHLf78Y1osPTDCpTxP0GRjDFBfcQ07nAxmzWQ6zPTS3tp6vQADXE0HQGfSFF2DAwwlkutHfg26zE3D7UcwmC3pN0jdhER4fp1e6+Hf30KBMxm0KPF8PbRb4ZYnTi7G1VJGqA3OhpnPEUhbpEnhB7eeqtt95aNwyDmzdv4jgO169f51e/+hXHjx+X3hFCSIUnhBASeEIIIYEnhBASeEIIIYEnhBASeEIIIYEnhBASeEIIIYEnhJDAE0IICTwhhHiUPQ3wT//0T9y8eZO1tTUcx+HLX/6y9IwQ4vEMvOPHj+/68oD3339fekYIIVNaIYSQwBNCCAk8IYSQwHuCNSiEvaQqj8rzCvEQ3LjEqy//B0rvPrhNHLJFfGzqM3kK4xXqloOq+4gM5Mj0engUVh9slseo66fp9claieJJ9AEXOIOnAAAfW0lEQVQr52cp/c3f8u4/3+DIbz7P1zrjvBRx8wzAByu88eZHGF2/w3MHkY/v/ZzS7F9yaeU9PjryDM8ZX6c33svX2h+RCq8xliAxYtE5PMfFpYvM5jowC3GSM+YjsLMdGvMjTNUsGffiSSzPaM7+gFf/5gb/euB7vDbxGt/7Ix8f/PRVxt+8tpGHdX76l/8v7924v2deKb3KjzafYytbf86PfvAjVtq/yXeGX+O17/0Znc/8nD//wY/4248ehcBzKoyPm4SGRjkTcKOpGu7QWUZzARoj49QAzEl6jC6S6TjhoB+vN0xirMbWct1Og1K6h6DXwPCHSU7WW7eZk/QYcfJjKbr8Bi4jSLxQxd6jGdW0n3CqQD4exOsy8IZTlJrbt1vVAomwH8Mw8HclmazbQI182E96YY0rIz34E6XWymX7tWcjIM2FLPGgF8PwEk5O0nC2K93aZJIuv9G6LVGguiNHnWaZbDyI1zDwBntIz+y9UplZSuL3J3a1X4gH4qOf89M3P+J3XhrgBXc7zxx5hnaji5c622n+zc/5+zde5U+G3uCfP64z/u00P16BG5de5eX0D/jzoW/z8p+M87f7BOkH763Q/MXuFHvvzb/k589+k4GXTvH8s8/wTLubr//RAC8cucRfXvrgEQi85iUajofOwO7poBrowGPXaWwVeRZ0DLN4cYmluX6YSpGvOoBNNZ2gYMWYuLjC0mw/jCc3bgPW6tSudjNxcZnLsxHsyQIzzb0rtdVaE1fuPEtXFsm5a+RHKq1AaYyRSFXQM3MsrywzO6AwlUhRMgPkFpcY7mzjxOAcS9O9aHdrD2uYlovM3BLLFycImQWShXorqGaSJKcU+meXWFk+T06vkkqM0QRwauQTWRq+YRaXV7g4EcMaSZCu2Lteg1VJE89b9E9P0OuW41E8YO+t8u6N5/lf3Ud2/fm5ru/xn7MR/pcXvsN/zr7Abz7tY+C1YV4yWrd//MFHtP9+ltdeG+Br956uNP/uPZ41jFumxs/jcz/De3/X5MahDzzbwVZUlFtPfykqCg7Xto5nN52h1hqzivs0AxGoztfBrjBV0ejPncajguo+zUBEobrQChHafPQPRtAVBdXXjU8zWd1zpqxwLDLAaY+KouhEOt04pokF1M8VMQMZchEdBQV3NMegp0axsscT3a09HCXQdwafpqBoATKDIezqAg2alIt1PAM5et0qKDqh3CAhs0ixDk61SNmJkskE0BRQPafJ9WtUipWN6tHBvpQnka4TmpjmrEeRg1E8hBntR9zgCM8cub+HPf2cn3/ztfbbH7fyY9Ivv8zLL/8JE/WP+cVPh3j55Zd5+U9+wBsf3ODGR/CM+sxtz3fkmSPc+Gj/OfPhuWihKqiOjWPDrisUjo2DwtF9rgNox1TsyxaOZWGtXWG408XwjtvbOu3t6Z6yM9bYc0q7VwBuPoFlWmi6vuNpNDRdxVq1AG33w+7YnttfjKJpqLaFhcVVS0HXdzyfoqNrNqYFtmXh6CfZuay4rmswb7Wm0axxYapEW5uGR5anFQ/LkWc4wgfcOKjnc/fy3f/zm8ANfv6j/4OF5/6M73zzOY5whGefPcKlZ+Aj+6M9cvcGR+6QuoenwnOfwqM0WLhlEWm7doGG6sOn7z39NFdtVFVDUTXUtpNkL6yyurr9szIR4aBqHE3XsCxzx/kyC9O0UY9pewT4/bXHMS1sVUND45jmYFo7T9qZmJaKpoGqaSjWKjsvjZimBZq2EbltnMye5/yQm0o6TVmuoYiH4TkXzx95l/++sjvyrlV+wLd/8AbXPkWAtre3097ezrPPwJFnnuW59nba25/lCM/g/lfP8cHKCu/tetC7/PfmRzzncnPk0AeeEmFgQKOaTTFTM7EdG7M2SSpfwzPQT2D7ZB/z5QY2YNcnGalAqNsHWohYoMlUvkTDBhyL2mSWsZp9YE30xaLo1REKNasVtpUCUw0ffVF9u2q8arUqx7u250OqxUnqloNj1RiZqqGFOvHgJtrnozFeoGI6gEW1MEJV7yPmAyXUR5QyhclWHzjNEoUpi0hfZKNuVNB1N+7eYYYDdbLpEqYcjuJBe+Z3+ObXn+HS7I94892PuMENPmhW+PFP3+U5/9doBzhyhCN8wLUPPnsd+NzXv8nXPvgp4z++xLsf3ODGB+9y6cc/4o0bp/j9rz/7CExpAc/ZWaaVPIV0F3nLQdF9RAanyZ3eedZdRbmcp6tQx0InMDBKLqQAGr2j09jZLAl/FltRcYcGGOpV73Xueg8NzDAx7JDNhjFMUN0B+icmOK23gibQdxo1lcDfzLE4e3r/9gDQjk9fpdDj5ZKl4IpkGM34WlPU06NM2FmyPV5Sjoru62V04iweACVAbjpHPpskWLBA87T6KHLrNFkjMjTKhZ4kqUkfc2fkyoV4oHNa3PHv8mdHfkzp1W8zacP/9JvP87VvfoeXXtj4YNxz/5pO401m/0Oaf/qz13jpHp/31J+9zqlb//zsKQa+C6XZv+TV9AQfofLc177OH3339/naM/s/21NvvfXW+smTJ2/7tpTjx48fvj41J+kJL9C3NEuvfLZXCHGf5L+WCSEk8IQQ4nHz9CPVWv0McytnZK8JIaTCE0IICTwhhJDAE0JI4AkhhASeEEJI4AkhhASeEEJI4AkhhASeEEJI4AkhhASeEEJI4AkhhASeEEIC71FWS+P3Z1vr1x6gRj6Mkaz82l6WU05gdG0s0fgIPK8QEnj3YmOx7JlbFp2ppLz4s7XHq9etGjNjFQkbIaTCewJYF5gamZfAE0ICb3/VtJ9gIk2yJ0zQ78Xfk6a8T2o4zTLZeBCvYeAN9pCeaWwvr2hVKSTC+A0DwxsmMVbbXufHqpLfeJy/K8lU075jRZofS9HlN3AZQeKF6tbz7Ld9q5TAH59kdW2elDdMvra52QKJsBfD8BKMZ9m1trd9malkV6u9wTj5inVvr9NuMJPuIeg1MLxB4tkyzb3WqrVr5Lu8dOVr2HJMCAm8w8LBsjQGphe5uHSRUU+ddHry9krJqZFPZGn4hllcXuHiRAxrJEG6YgMmM6kUFT3H+ZUVlmdj2CNpCnUAi1I6RVkdYHZpmcWJGJh3iIC1OrWr3UxcXObybAR7ssBM887b13qnWZo9g6utm9HlRXIBoDlJMlVFzy2yvLzIkKdOOjW5vbyi1YTYBIvLS5wfVCmn05Ssu71Om0o2wYjVzejFFVYWh/E1siQKdXZlnt1gMpmi4h5mOhdA1kYSEniHhoLm68SnAqgEBvvxNeap3XLez6kWKTtRMpkAmgKq5zS5fo1KsYKNRmR4jtlcCA1QPBE63RZm0wa7ynxNo3fwNB5VQdUj9If0/ZvT5qN/MIKuKKi+bnyayap5t+3frlGcohkYJBfSUBSN0EA/nsYC1c3X5Y7RH9FRFRV3b4ZercZ8zb7zduwKxYpGf+5Mq7+0AJlcFEpFapuJ56xSTCUYVwaZHo2gyfEgHnNPP9KtVzVUbK7eEni2ZeHoJ9kZVbquwbyFhYJm1ylk09SaFg5gW+ADsG1sdFz6fWXwrn/ad90+t1VRpmXx4cIAJ1w7w/QEHXsWlyouDWqWja3cYTsWWGjoO2/UXGjOAtZm4K2eY8ZsQ/E5ciQIqfAebnipqFjYuw5yG9t2UNV9JlqWiYXKMe3WHNRQrFV25qBpWqBpaNQoJApY3cOcv3iRixenGXDvbIN9Sxs+TQ7fafu301SN9tgUV1ZXWd38WTnP2T3XzrZYtUDV1DtvR9PQsDB3ngu0VrEUDW0zpNtjTCxO02uNkCo0kNgTEngPLfACdPsspvKT1C0HsGmW84zXdCLdnu1zeLVzrameY1IuTNHwdBO6JUWUUB9RyhQmG9iA0yxRmLKI9EVQHXurwnFsi0alyPzmSUA1RHegSXG82goRu8583bz/ifedtg+gHEXBwjJbDfHEIqiVEQpVs1VxNsvk86Xtc3jNc4xXTGzHplkaoWQF6A6od96OGiIWspgqlFoXKuw6Y4UyRPsIKNsVn64HyIwOwEyKQk0uWQgJvIdEp3dimgF1nlT4BC6Xn/i4TWRimoxnZ/VkU0z48XrD5M0Aw6NnuG0GqgTITedwLyQJGgb+RBF1cJqhiApKhMxQCKvQhd/fRXq+nUBAx7EtQKN3eJRQM0vYHyQYH8FUP8WZrTttH8AdoS/QJB8Okq2B4ssxPeyjke/CaxgEk+fgVGD7dbl9qOcSBL0n6RqxiY4O06vdbTsa0eFpBpUp4n4DI5jignuI6Vxg5yy81VzPWSYyGqV0nopknniMPfXWW2+tnzx5kps3b+I4DtevX+f999/n+PHjh66x1bSfrDLBxSGf7DkhxKNc4QkhhASeEEIciEfqYymh4SUuyj4TQkiFJ4QQEnhCCCGBJ4SQwBNCCAk8IYSQwBNCCAk8IYSQwBNCCAk8IYSQwBNCCAk8IYS4N/v+X9pr165J7wghnozAa29vl94RQsiUVgghJPCEEEICTwghJPCEEEICTwghJPCEEEICTwghJPCEEEICTwghgSeEEBJ4QgghgSeEEBJ4QgghgSeEEE9y4FVJe124XJs/Bv5wgny5iSP7SQjx+FV4R+kev8Lq6iqrVy4yPaBSSaeYbMqOEkI8jlNaRdn4reHp7SeiNbncaNV4jlkhHw/iNQy84QSFqtW6rzlJjxEnP5aiy2/gMoLEC1Xsjae065OkuvytxwXj5Cvmxi118kEviWyWeNCLYXgJJ2eo1WZIdfkxXAb+rjTlzbtjU59sbcMw/PSkSzSl/BRCAu+zs2mUpqhYHk55FHDqFBJpGh2jLK4sc35QpZzKUt7IPNbq1K52M3FxmcuzEezJAjNNwK6QTkzBwBxLK8vMDSiU0gUqW0H1IQ3rJEPnl1leHMLTyNGXvkTH6CLLV84zqFXIFqo4gFVKkZyCgbllVpYm6DTzJEcaMoqEkMD7ND5kvn/zHN5Jugs2fdMTnHGDUytSsqMMnvWhoaBHB+nTa8zXN5KrzUf/YARdUVB93fg0k1UTUAPk5uYYiuooKLgjnXgcE9PankYHYr24VVD0KN2+No5F+ul1qyiKm0inB8cysTEpF2u4B3JEdQVUH2f6Q1jVKjLjFuLR8PThas5RuqeWGQ2BU00TTNvoHq01nbVMPrx2iT5Xccf92zhl2Tumw7v/aW/8y2mOk05XaFgO4GCt6XTuP6dG2flEQOuqicWqtcal3ClcuR23tatYgFvGkhASeJ+WEhpkQA8zMt4gmvGgqBpHXQPMLmbw3Hpn8w5P1Bghla4Tm51jwqOCXSLuL36KFqkcU4/SmbnIRFSVkSOETGkPks7pwSj2zAhlC5RAjIhdIj9WxwKw68zkC1SsuzyNbbN5F9tqUp05R2PNwbnviw1uIjE3tZE85WarUjQrBbIzDfnYjBASeAdU5bmrjEw1QA0xNJ1BX0gRNgyMcJYL7R34tLs8SWCQoV6Y6vHj70pS/NBHyAUf2vffHveZCUYjNiNxL4bhJz5ucTLgvnUCLIQ4pJ5666231k+ePMnNmzdxHIfr16/z/vvvc/z4cekdIYRUeEIIIYEnhBASeEIIIYEnhBASeEIIIYEnhBASeEIIIYEnhBASeEIICTwhhJDAE0IICTwhhJDAE0IICTwhhJDAE0IICTwhhJDAE0KIRy7wamT9LlzhAnut9NoohHG5/KRrstOEEI9Lhbdaoli7ZVkcp8ZUaVX2lhDicQq8Y5zqUClPVdi5xo5dmaKidtBxbOcfG8ykewh6DQxvkHi2TNMBaJAPe0lVtkOzng/iT1VwAMeskI8H8RoG3nCCQtWSUSCEBN6vhzvWh6dWpLy11qxFuVjD0xdD3047KtkEI1Y3oxdXWFkcxtfIkijUcfAQi2hU56sbyyfWma84hGIhFKdOIZGm0THK4soy5wdVyqksZck8ISTwHj4HR43SF2hQLDdbf2qWKDYC9EU1thaAtSsUKxr9uTP4VEALkMlFoVSk5oAnFkOvzlN1gMY8VSdELKDg1IqU7CiDZ31oKOjRQfr0GvN1WVlWCAm8X0fgoRHpj2IXp6g5DrWpIna0n4i2Y/Fsy8JCQ9d3PFRzoTkmlgO4o8TcNearNo35Kk4khk8BxzL58FqRPpcLl8uFy9XJ8BUH27JlJAjxBHj6MDZKCfQRVRJMlU+iVBSi0wEUqjvCTUPDwjQB92YIrmIpGpoCoBPp1hk/N47adIgMB1qLZasaR10DzC5m8Mi+F0IqvMPBQ1+/m2o2S9XdT9+t6aSGiIUspgql1oUKu85YoQzRPgJK6y56NIa7Ok7JidDt2wzSGBG7RH6sjkXrcTP5AhU5hyeEBN6vkx7tI6QoBPqi6LfdqhEdnmZQmSLuNzCCKS64h5jObVRyAFqEWKANPRrDtyMoh6Yz6AspwoaBEc5yob0DnyYDQYgnwVNvvfXW+smTJ7l58yaO43D9+nXef/99jh8/Lr0jhJAKTwghJPCEEEICTwghJPCEEEICTwghJPCEEEICTwghJPCEEEICTwghgSeEEBJ4QgghgSeEEBJ4QgghgSeEEBJ4QgghgSeEEBJ4Twhzkh4jTknWGxLicQi8Glm/C1e4QGOPWxuFMC6Xn3Tt4bSmWR6jVP806WJSnZykasrgEkIC725WSxRrt6wT69SYKq0+xEY4NOZHmKp9mtV9msyPT7EgCwMJIYF3Z8c41aFSnqqws7ayK1NU1A46ju38Y4OZdA9Br4HhDRLPllsrmNEgH/aSqmyHZj0fxJ+q4ACOWSEfD+I1DLzhBIWqdVulmQ/7SS+scWWkB3+ihAU4zTLZzccFe0jPNLht+e7GGD3eJOVrVynFvfSMNTemomESqS78Rph8A7CqFBJh/IaB4Q2TGKttvV6nUSLV48fY3E6puWM7DpfGU3T5DVxGkHihisxwhXiEKzx3rA9PrUh5a0poUS7W8PTFdqxeZlPJJhixuhm9uMLK4jC+RpZEoY6Dh1hEozpf3QiKOvMVh1AshOLUKSTSNDpGWVxZ5vygSjmVpbwr8wLkFpcY7mzjxOAcS9O9aE6NfCJLwzfM4vIKFydiWCMJ0pVb4sZzlrnlCaLtx+idXWbu7MaiuWsWzokhzi+fJ+cxmUmlqOg5zq+ssDwbwx5JU6i3qsPJdBazc5qllRUWhzzUs2lmNvtirUHD7mbi4jKXZyPYkwVmmjKIhXhEA8/BUaP0BRoUyxtHcrNEsRGgL6qxVerYFYoVjf7cGXwqoAXI5KJQKlJzwBOLoVfnqTpAY56qEyIWUHBqRUp2lMGzPjQU9OggfXqN+bpz51ZVi5SdKJlMAE0B1XOaXL9GpVi5twqrzUPstA9NUQCNyPAcs7kQGqB4InS6LcymDSgoCtirTUwbtFCOuYsT9G4mfZuP/sEIuqKg+rrxaSarcq5QiEc48NCI9Eexi1PUHIfaVBE72k9Ec3A2c8mysNDQdy5Yq7nQHBPLAdxRYu4a81WbxnwVJxLDp4BjmXx4rUify4XL5cLl6mT4ioNt3Tm2bMvC0V271sfVdW2jHfdLQbHrjCR7CAeDBIMJxreqNJ0zExP0USQV9uLvSjJSs7fX2m09fNc/HRnDQtyzpw9jo5RAH1ElwVT5JEpFITodQKG6I9w0NCxME3BvhuAqlqKhKa3giHTrjJ8bR206RIY3FuhWNY66BphdzOC5j/aomoZirWLBVuiZprXRjvtVo5AoYGVmOd/rRqHJWFcXlzam703LTe/wLGcAq14gmUhScC+SU2WwCvGYVXibPPT1u6lms1Td/fTdmk5qiFjIYqpQal2osOuMFcoQ7SOwUQHp0Rju6jglJ0K3bzNIY0TsEvmxeqsys+vM5AtUrL3qMLCvWtiAEuojSpnCZAMbcJolClMWkb4It+eQiqLYWOY+VaNjt6pQwLEtGpUi85sVnl1nJLF9oUJVj6HiSBknxOMdeKBH+wgpCoG+6K6p5EaJR3R4mkFlirjfwAimuOAeYjoX2J7xaRFigTb0aAzfjqAcms6gL6QIGwZGOMuF9g582u1xF+g7jVpO4I/PYCoBctM53AtJgoaBP1FEHZxmKKLuGdaxPje1tJ+uwh6fKFQiZIZCWIUu/P4u0vPtBAI6jm2BGmFoYgCm4vgNA2+8iDI4yqBPBqoQB+Gpt956a/3kyZPcvHkTx3G4fv0677//PsePH5feEUJIhSeEEBJ4QgghgSeEEBJ4QgghgSeEEBJ4QgghgSeEEBJ4QgghgSeEkMATQggJPCGEkMATQggJPCGEkMATQoiHbt9vPL527Zr0jhDiyQi89vZ26R0hhExphRBCAk8IISTwhBBCAk8IISTwhBDioQbeP/7jP8pv+S2/5fdj83vfZRrb2trk7UAIIVNaIYSQwBNCCAk8IYSQwBNCCAk8IYSQwBNCCAk8IYR4hAJv7Z2/5tVvv0h35AUi3T38cfZ13vyF7CQAfvkzsj1/zOvv3Ofj3nmdl154gRdeeIEXXojQ/eK3eaW0xP+440P+mJ7sz/il9LqQwHtQB/SbvJL5Ie/6/z3/Ze7/Yf4vXiPx5SVeyfyQxprsKL7o5+X/+B1+7/lP8dgj/xvfLb/BG2/M8+Oh3+OLP/s+3/r+m/uG3vO/9x3+48t+vii9LiTwHpBfNHjnl7/N737jJF/5YhttX3yer7/8p/ze82v84n8ArPHOX7/Ct17sJhLppudbr/DX764B7/DDl7r5/pvbqdj44Yv0fP9N1oC1X7zJD7/9It2RCN0vZXh9ae/D/JeNEt//457W/V78Nj/cr7T8ZYPS9/+Ynu4Ike6XyLy+XS2tvfuzjQo1QveL3+KVv3qHzVYtvdLDi5lXyH7rJV7sabX/Z+8Ca0u80tNN9meb9dQv+Vm2m55XL99S/i7xeuYV/updgHd4/aUesq+/TualVn+8mCndwxtDG1/+7d/lT4f+lOeXXqf0zuZzdfOtbJaXuiN8q/QL3v2rV8i8vsTaAfWtEBJ4t/rt3+Ubv/0OxVde5813/kcrKL54kpeHvsPvfgXWLv+Q/7+dO4Rx24rjOP4F2yN9yGQmTYkrbSEzMjKZkcEWcApoA6qAKmAK6AJOAacD0YHsgHUgOhBV0+nA7UB2IDtgHfBIkEs8EmTkDQS9SpNLXsnApV3Wu66Vbt269f8hT0qk2PpH/uX/f06yMzHE+2dcXBwzcAuSJMPgEYcOeZavw2VJtrAEcYCyS6bbY8pgl+OLcx53NdkoITPXdZcz6BxydnHOYUeRjqcsrgSIIRvvMKPDwdkF5497OIsR49SALZhsJ5TNIcfnF5zuxZijbcaLF0FmMcahs3/M6dkpu96S8XhGpXziUFFk+eUIaQsWhSaM/DcU7CnFUtM5OOP8dIhfTZmmbxk4jk/QWFEUL0L9GSsCdk/POWy7m2/KzWsrhATetYlH5+CQvm+YjR6wtfWQnUlGuc4L5XXYf7xLq6EAhyDyYFWyArw4xs0zcguUGbkNiH2FLeakdUS308RB4UZdWm5B9morpH36h4cMIheFohGGeHa17iw3827BPHdp9yIaCpQb0hv0CR2LzedkNqLX83EUaK9Fv+2wmC/We2EKpxnS1AAav9umWWYURuFHIbrIyGuwxYJCB7wx77hF0O7gOwrlhIRNxap62w1PjdZQW/vytfy4haev/n76xrUV4j3y0Xt1NqpB2BkSdqCuctJpwqNHJQePe3hasZonJOmSlQWs4blqrTedIuLGjCyvcZc5NhzQVGDNimdPf+abL37c3NDic1MDzp9GPVudMB4vKI297Maeu4RXxtmaGgfH2WyWYlqAmRus22SzP3JdB4y5fq9MO2jqy1D1YwK9TZYbdJ6jgl38d1romroGrRTwhoC6cW2FkMC7wuRTJoVPvxfgALoR0B52ybdOyMoeejlilHnsHZziO8BixJeTl9FCGLmcpCfoyhIOfdQ6VG7dvs/BcQ/vrw5eHjEaL4kPDtnzNNQpj7bmrwkpgzHwItnsaklpG3iOgzIVG0+xWhlwHBzgSu9lVhg0gQPQJA412+kRqlIEu/67LjaL0qHZd4E33fa9YW2FkJH2mm0lV1PNEybpErPu4JZpRqkaeC7Yul73IjX1qmCeLnm2eVlGMY38e1IbEjXXfZsfE9Ypk5PlZZdVL5lPpizM1c7txUO1qcjnKeVzi321+XECYr9idrS47DJNznRnh6OlRQUtIjKms5IasFXKdGYIW+H6bqfFFCm5AeyKbDqj9KJ14EEzDtFPfuQnAuLmu6qyxZQZyfaUKujRecvj3Ki2QkiHd93o1OFgXzOZjnmY/MJTbvGJF9DZHxBpoNWnWyTs3JuD6xOHPp9V9WU4KsAJif0Jxot5eR3rgMF+jyQZ8eDIYHWDoN1n8OrE5XcZxCMmX28x1S5BHBLczqmvfBHNIR7uYZKEr78cUWuXoL3LMHYAh/5+n0myw72pAccj7O7TD/VGg1gz395iVNUoL2K42/5jBPZiots/kPkb5/93ef6Eb7/6gm/5mFufeAStIYft8O0Hz5vUVoj3iPwB6D8kH2+RqD1OB6+Ls4qTh9uYwSn9ptRLiP/1SPtBszVVesTcRu9wnBVCSOD962qy0T0eHtW0hl25ASCEjLRCCCEdnhBCSOAJIYQEnhBCAk8IIT7YwLtz546sssoq6/9qfe1d2rt378rHgRBCRlohhJDAE0IICTwhhJDAE0IICTwhhJDAE0IICTwhhJDAE/9Fv37H1qf3mf0mpRB/n98BhjzlYnwE+QEAAAAASUVORK5CYII=)

  Then follow the instructions in each cell below to complete the tasks. The tasks will be marked as **to do** in the cells.

* You will need to submit the **EDITOR** link on Canvas (click share --> get link --> editor --> copy link)
![Screenshot from 2021-09-02 15-45-25.png](data:image/png;base64,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)
"""

# First, let's set seed as 2021 here, so we have a repeatable result.
import random
import numpy as np
import pandas as pd

my_seed = 2021
random.seed(my_seed)
np.random.seed(my_seed)

# Then let's install surprise
!pip install surprise

# Let's use Surprise to download the ml-100k dataset (https://grouplens.org/datasets/movielens/100k/). Please input "Y" when being asked "Do you want to download it".
from surprise import Dataset

data = Dataset.load_builtin('ml-100k')

"""## Task 1: Data Exploration (5 points)

In this task, we will do basic exploration on the ml-100k dataset. This will help us know what's in the dataset and how to get its data.

Your task is to

1) calculate the number of distinct users and the number of distinct movies in ml-100k.

2) like the example of number of ratings/user histogram below, plot the histogram (set bins=10) of number of ratings/movie of ml-100k.
"""

# ml-100k has 100k records in total.
print(len(data.raw_ratings))

# each record incluedes (userId, movieId, rating, timestamp)
print(data.raw_ratings[0])

# Task 1 to do: calculate the number of distinct users as n_user and the number of distinct movies as n_movie
userlist = []
movielist = []
for i in data.raw_ratings:
  if (i[0] not in userlist):
    userlist.append(i[0])
  if (i[1] not in movielist):
    movielist.append(i[1])
n_user = len(userlist)
n_movie = len(movielist)
print(n_user, n_movie) #2.5 points for each

# How many ratings each user gave?
from collections import Counter
user_list = [x[0] for x in data.raw_ratings]
c = Counter(user_list) # c is the number of ratings each user give
import matplotlib.pyplot as plt
n_rating_peruser = c.values()
# let's draw a histogram on n_rating/user
n, bins, patches = plt.hist(x=n_rating_peruser, bins=10)
plt.xlabel('n_rating/user')
plt.ylabel('frequency')
plt.show()
plt.close()
# As the figure shows, most users (over 500) gave 0~100 ratings.

# How many ratings each movie has?
# Task 1 to do 2: similar to the histogram above, please plot the historgram of number of ratings per movie
from collections import Counter
movie_list = [x[1] for x in data.raw_ratings]
c = Counter(movie_list) # c is the number of ratings each movie was given
import matplotlib.pyplot as plt
n_rating_permovie = c.values()
# let's draw a histogram on n_rating/movie
n, bins, patches = plt.hist(x=n_rating_permovie, bins=10)
plt.xlabel('n_rating/movie')
plt.ylabel('frequency')
plt.show()
plt.close()

"""## Task 2: evaluate the built-in algorithms (10 points for implementing it correctly, -0.5 for each entry if error > 0.002)

In this task, you will evaluate Surprise's four built-in algorithms and show 2 built-in metrics over those algorithms.

Ref: https://surprise.readthedocs.io/en/stable/getting_started.html

1) 4 algorithms:

from Surprise: bias(BaselineOnly), UserUser(KNNBasic), ItemItem(KNNBasic), NMF(NMF); for KNNBasic, change sim_options to use UserUser or ItemItem

2) 2 metrics: evaluate rmse, mae

3) use the **my_split** method (set randome_state=2021) below to implement 5-fold evaluation and report **the average scores of the 5 folds** in **metric_report** -- evaluate rmse and mae on **testset_rated**.

You will fill in the **metric_report** below, whose entry (algorithmm, metric) is the performance of the algorithm on that metric.

To check your result: rmse of Bias is around 0.944.
"""

from surprise.model_selection import KFold
from surprise import BaselineOnly
from surprise import KNNBasic
from surprise import NMF
import copy
tmp = pd.DataFrame(data.raw_ratings, columns=["userId", "movieId", "rating", "tstamp"])
rating_df = tmp.pivot(index='userId', columns='movieId', values='rating')

def partition (list_in, n):
    random.seed(2021)
    random.shuffle(list_in)
    return [list_in[i::n] for i in range(n)]

non_rated_movies = []
for userId in rating_df.index:
  tmp = rating_df.loc[userId].loc[rating_df.loc[userId].isna()].index
  for movieId in tmp:
    non_rated_movies.append((userId, movieId, 0))
n_splits=5
non_rated_testset = partition(non_rated_movies, n_splits)

def my_split(data, n_splits=5, random_state=2021):
    """
    The method to generate the splits of trainset, testset_rated (testset with rated items only), testset_withunrated (testset with unrated items, and set their ''true rating'' as 0)
    Parameters:
    data: suprise dataset, https://surprise.readthedocs.io/en/stable/dataset.html#surprise.dataset.Dataset
    n_splits: number of splits
    random_state: seed
    Returns:
    dataset: a list (length = n_splits) of tuples (trainset, testset_rated, testset_withunrated),
            and each of the trainset/testset is a list of tuples (userId, movieId, true rating)

    """
    kf = KFold(n_splits=n_splits, random_state=random_state)

    dataset = []
    i = 0
    tmp = copy.deepcopy(data)
    for trainset, testset_rated in kf.split(tmp):
      testset_withunrated = copy.deepcopy(testset_rated)
      testset_withunrated.extend(non_rated_testset[i][:len(testset_rated)])
      dataset.append((trainset, testset_rated, testset_withunrated))
      i += 1
    return dataset

from surprise import accuracy
metric_report = pd.DataFrame(index=['Bias', 'UserUser','ItemItem','NMF'], columns=['rmse','mae'])
# Task 2 to do start: fill in metric_report.
# sample random trainset and testset
mylist = my_split(data)

sim_options = {"user_based": False} #itemitem
sim_options1 = {"user_based": True} #useruser

algo = BaselineOnly()
algo1 = KNNBasic(sim_options=sim_options1)
algo2 = KNNBasic(sim_options=sim_options)
algo3 = NMF()

algoAcc = []
algo1Acc = []
algo2Acc = []
algo3Acc = []
algo4Acc = []
algo5Acc = []
algo6Acc = []
algo7Acc = []

for i in mylist:
  trainset = i[0]
  testset = i[1]
  # Train the algorithm on the trainset, and predict ratings for the testset
  algo.fit(trainset)
  algo1.fit(trainset)
  algo2.fit(trainset)
  algo3.fit(trainset)
  predictions = algo.test(testset)
  predictions1 = algo1.test(testset)
  predictions2 = algo2.test(testset)
  predictions3 = algo3.test(testset)
  algoAcc.append(accuracy.rmse(predictions, verbose=False
))
  algo1Acc.append(accuracy.rmse(predictions1, verbose=False
))
  algo2Acc.append(accuracy.rmse(predictions2, verbose=False
))
  algo3Acc.append(accuracy.rmse(predictions3, verbose=False
))
  algo4Acc.append(accuracy.mae(predictions, verbose=False
))
  algo5Acc.append(accuracy.mae(predictions1, verbose=False
))
  algo6Acc.append(accuracy.mae(predictions2, verbose=False
))
  algo7Acc.append(accuracy.mae(predictions3, verbose=False
))

algoAve = 0
algo1Ave = 0
algo2Ave = 0
algo3Ave = 0
algo4Ave = 0
algo5Ave = 0
algo6Ave = 0
algo7Ave = 0
for j in algoAcc:
  algoAve += j

for j in algo1Acc:
  algo1Ave += j

for j in algo2Acc:
  algo2Ave += j

for j in algo3Acc:
  algo3Ave += j

for j in algo4Acc:
  algo4Ave += j

for j in algo5Acc:
  algo5Ave += j

for j in algo6Acc:
  algo6Ave += j

for j in algo7Acc:
  algo7Ave += j

algoAve = algoAve/5
algo1Ave = algo1Ave/5
algo2Ave = algo2Ave/5
algo3Ave = algo3Ave/5
algo4Ave = algo4Ave/5
algo5Ave = algo5Ave/5
algo6Ave = algo6Ave/5
algo7Ave = algo7Ave/5

metric_report.iloc[0][0] = algoAve
metric_report.iloc[1][0] = algo1Ave
metric_report.iloc[2][0] = algo2Ave
metric_report.iloc[3][0] = algo3Ave
metric_report.iloc[0][1] = algo4Ave
metric_report.iloc[1][1] = algo5Ave
metric_report.iloc[2][1] = algo6Ave
metric_report.iloc[3][1] = algo7Ave

# Task 2 to do end
print(metric_report)

"""## Task 3: implement the ndcg metric to evaluate predictions. (10 points)





Let's implement the ndcg metric (Normalized Discounted Cumulative Gain). NDCG is the metric of measuring ranking quality.


* DCG accumulated at rank position k is given by
$DCG_p = \sum_{i=1}^k \frac {rel_i} {log_2 (i+1)} = rel_1 + \sum_{i=2}^k \frac {rel_i} {log_2 (i+1)}$.
Here $rel_i$ is relevance of the result at position i -- we could **use the true rating of the movie at position i as $rel_i$**, and **treat the unrated movies' true ratings as 0**.

* Normalized DCG (nDCG) is given by
$nDCG_k = \frac {DCG_k} {IDCG_k}$

  where
$IDCG_k = \sum_{i=1}^{|REL|} \frac {2^{rel_i} - 1} {log_2 (i+1)}$.  This is done by sorting all relevant documents in the corpus by their relative relevance, producing the maximum possible DCG through position
k -- called Ideal DCG (IDCG) at k.

* https://scikit-learn.org/stable/modules/generated/sklearn.metrics.ndcg_score.html#sklearn.metrics.ndcg_score

In this task, you could use the ndcg_score of sklearn to calculate the score -- you need to figure out the correct input/output format, and **return the average ndcg@5** (**set k=5**) across all users' recommendation lists.

* https://scikit-learn.org/stable/modules/generated/sklearn.metrics.ndcg_score.html#sklearn.metrics.ndcg_score

"""

from sklearn.metrics import ndcg_score
from scipy import sparse
def ndcg(surprise_predictions, M, N, k=5):
    """
    Calculates the ndcg (normalized discounted cumulative gain) from surprise predictions, you could use sklearn.metrics.ndcg_score and scipy.sparse

    Parameters:
    surprise_predictions (List of surprise.prediction_algorithms.predictions.Prediction): list of predictions,
    see https://surprise.readthedocs.io/en/stable/predictions_module.html?highlight=prediction#surprise.prediction_algorithms.predictions.Prediction
    M: number of users
    N: number of movies
    k (positive integer): Only consider the highest k scores (items) in each user's recommendation list.

    Returns:
    float in [0., 1.]: The averaged NDCG scores over all users' recommendation lists.

    """
    # Task 3 to do start: return the ndcg score, with the help of sklearn ndcg_score package
    # hint: build 2 M x N matrices, each row representing the predicted/true ratings for one user -- and input that 2 matrices into ndcg_score directly.
    # ....
    i = len(surprise_predictions)
    counter = 0
    pred_ratings_mat = []
    for row in range(0, M):
      row1 = []
      for col in range(0, N):
        row1.append(0)
        #pred_ratings_mat[row][col] = 0
      pred_ratings_mat.append(row1)
    true_ratings_mat = []
    for row in range(0, M):
      row1 = []
      for col in range(0, N):
        row1.append(0)
        #true_ratings_mat[row][col] = 0
      true_ratings_mat.append(row1)
    for i in surprise_predictions:
      pred_ratings_mat[int(i.uid)-1][int(i.iid)-1] = i.est
    for i in surprise_predictions:
      true_ratings_mat[int(i.uid)-1][int(i.iid)-1] = i.r_ui
    hi = ndcg_score(true_ratings_mat, pred_ratings_mat, k=5)
    return hi
    # Task 3 to do end

"""## Task 4: implement the intra-list similarity metric (ILS) based on tag genome. (10 points)

In this task, we will implement ILS based on tag genome (https://files.grouplens.org/datasets/tag-genome/README.html). The tag genome encodes how strongly movies exhibit particular properties represented by tags (atmospheric, thought-provoking, realistic, etc.). The tag genome was computed using a machine learning algorithm on user-contributed content including tags, ratings, and textual reviews.


Intra-list Similarity: ILS is a diversity metric. If you recommend a list L of recommendations ($item_1,...,item_n$) to a user, the ILS of this list is defined as $ILS(L) = \frac{1}{|L|\times(|L|-1)/2}\sum_{i\neq j, i,j\in L}Similarity(item_i,item_j)$. Here $Similarity(item_i,item_j)$ could be defined as the pearson correlation between $item_i$ and $item_j$'s representation in taggenome.

Your task is to calculate **ILS@5 (set k=5)** for each users' recommendation list, and **return the average ILS@5** across all users' recommendation lists.
"""

from scipy import stats
# This cell help you get the dataframe movieId x tagId,
# whose entries (i,j) represent the relevance between movie i and tag j.
url = 'https://drive.google.com/file/d/1eATlHqQKzAocs03Woxm4Bq8bJ-yeBLxa/view?usp=sharing'
path = 'https://drive.google.com/uc?export=download&id=' + url.split('/')[-2]
movie_tags = pd.read_csv(path, index_col=0)
movie_tags.index = movie_tags.index.map(int).map(str) #the index of movie_tags has type str

print(movie_tags)

# Task 4 to do 1:
# calculate the similarity (Pearson Correlation) between movie Id 2 and Id 3 by movie_tags.
movie1 = movie_tags[0:1]
movie2 = movie_tags[1:2]
movie1arr = movie1.to_numpy()
movie2arr = movie2.to_numpy()
sim = stats.pearsonr(movie1arr[0], movie2arr[0])
print("the similarity (Pearson Correlation) between movie Id 2 and Id 3 is ", sim[0])

def intra_similarity(surprise_predictions, k_highest_scores=5):
    """
    Calculates the intra-similarity score from surprise predictions

    Parameters:
    surprise_predictions (List of surprise.prediction_algorithms.predictions.Prediction): list of predictions,
    see https://surprise.readthedocs.io/en/stable/predictions_module.html?highlight=prediction#surprise.prediction_algorithms.predictions.Prediction
    k_highest_scores (positive integer): Only consider the highest k scores (items) in each user's recommendation list.

    Returns:
    float in [-1, 1.]: The averaged ILS@5 over all users' recommendation lists.

    """
    uidset = list(set([p.uid for p in surprise_predictions]))
    iidset = list(set([p.iid for p in surprise_predictions]))
    ratings = pd.DataFrame(index=uidset, columns=iidset)
    for prediction in surprise_predictions:
      ratings.loc[prediction.uid, prediction.iid] = prediction.est
    ratings.fillna(0, inplace=True) # now we've transformed the predictions into a userId x movieId pred_rating dataframe
    # Task 4 to do 2 start: calculate and return the average ILS@5 by movie_tags;
    # if a movie in the top 5 list is not in movie_tag's index, remove that movie from the top 5 list (but you don't need to add new movies to this top 5 list)
    # only count the non-empty top 5 lists' ILS
    myratings = []
    vals = ratings.apply(lambda s, n: pd.Series(s.nlargest(n).index), axis=1, n=k_highest_scores)
    for user in range(0, len(vals)): # check syntax
      row = vals.iloc[user]
      row = row.to_numpy()
      for j in row:
        if j not in movie_tags.index:
          row = np.delete(row, np.where(row == j))
      # for i in range(0, len(vals.index)):
      #   for j in range(0, len(vals.iloc[i])):
      #     if vals.index[i] not in movie_tags.index:
      myratings.append(row)
    # print("myratingslenbefore:", len(myratings))
    # for j in range(0, len(myratings)):
    #   if myratings[j].shape[0] <= 2:
    #     myratings.remove(myratings[j])
    # print("myratingslenafter:", len(myratings))
    ils_arr = []
    for user in range(0,len(myratings)):
      if myratings[user].shape[0] >= 2:
        total = 0
        counter = 0
        for i in range(0, myratings[user].shape[0]):
          for j in range(0, myratings[user].shape[0]):
            if (i != j):
              movie1 = movie_tags.loc[str(myratings[user][i])].to_numpy()
              movie2 = movie_tags.loc[str(myratings[user][j])].to_numpy()
              sim = stats.pearsonr(movie1, movie2)
              total += sim[0]
              counter += 1
        #row_ils = sim/counter
      ils_arr.append(total/counter)
    average = statistics.mean(ils_arr)
    return average
    # Task 4 to do 2 end

"""## Task 5: implementing the funk svd algorithm(10 points)
In this task, you will implement part of the funk svd algorithm https://sifter.org/simon/journal/20061211.html (especially the part starting from *So, yeah, you mathy guys are rolling your eyes right now as it dawns on you how short the path was.*)

You will fill the self.predict_ratings in the fit function. You should iterate the following process for n_epochs=20 rounds, set k=10, learning_rate=0.005, gamma = 0.02 (see their explanations in the comments below).

The steps of funksvd is a nested loop with k features (10 by default), each of them trained through some iter iterations (50 by default).:

For each feature f

--- For iter = 1,..., n_epochs

------ For each user, movie, rating pair, if the user has rated this movie

--------- 1) diff = rating - predictRating(movie, user);

--------- 2) userFeature[user, f] += learning_rate * (diff * movieFeature[f, movie] - gamma*userFeature[user, f]);

--------- 3) movieFeature[f, movie] += learning_rate * (diff * userFeature[user, f] - gamma* movieFeature[f, movie]);
"""

from surprise.prediction_algorithms.predictions import Prediction
class MyFunkSVD():
    def __init__(self, k=10):# we will change k in the next task
      # k: number of hidden features
        self.predict_ratings = None
        self.k=k

    def fit(self, trainset, learning_rate=0.001, n_iter=50, gamma = 0.015):
        # trainset: training dataset, https://surprise.readthedocs.io/en/stable/trainset.html?highlight=trainset
        # learning_rate: speed of apply diff (see equation 1 above)
        # n_iter: number of optimize iterations
        # gamma: the weight of original feature in updating, see equation 2, 3 above
        # this function return nothing, but you need to fill in self.predict_ratings whose element i,j  is user i's predicted rating for movie j
        raw_ratings = pd.DataFrame([x for x in trainset.all_ratings()],
                                   columns=["userId", "movieId", "ratings"])
        self.ratings = raw_ratings.pivot(index='userId', columns='movieId', values='ratings')
        self.ratings.index = self.ratings.index.map(str)# get the list of userId (type str)
        self.ratings.columns = self.ratings.columns.map(str)# get the list of movieId (type str)
        self.predict_ratings = pd.DataFrame(index=self.ratings.index, columns=self.ratings.columns)

        ratings = self.ratings.values
        n_users = ratings.shape[0]
        n_movies = ratings.shape[1]
        # here we initialize a random user by feature matrix and a random feature by movie matrix.
        # you will need to optimize the entries of these 2 matrices in your funksvd algorithm
        user_feature = np.random.rand(n_users, self.k)
        movie_feature = np.random.rand(self.k, n_movies)
        # Task 5 to do start: fill in self.predict_ratings
        mylist = []
        for user in range(0, len(ratings)):
          for movie in range(0, len(ratings[user])):
            if np.isnan(ratings[user][movie]):#-2 if not np.isnan() here?
             mylist.append((user, movie, ratings[user][movie]))
        for f in range(0,self.k):
          for i in range(1,20):
            for j in mylist:
                  diff = j[2] - np.dot(user_feature[j[0], :], movie_feature[:, j[1]])
                  user_feature[j[0], f] += learning_rate * ((diff * movie_feature[f, j[1]]) - (gamma * user_feature[j[0], f]))
                  movie_feature[f, j[1]] += learning_rate * ((diff * user_feature[j[0], f]) - (gamma * movie_feature[f, j[1]]))

        dot_mat = np.dot(user_feature, movie_feature) # matrix multiplication
        self.predict_ratings = pd.DataFrame(dot_mat, index = self.ratings.index, columns=self.ratings.columns)
        # Task 5 to do end


    def test(self, testset):
      estimations = []
      for userId, movieId, true_rating in testset:
        if userId in self.predict_ratings.index and movieId in self.predict_ratings.columns and not np.isnan(self.predict_ratings.loc[userId, movieId]):
          pred_rating = self.predict_ratings.loc[userId, movieId]
          estimations.append(Prediction(uid=userId, iid=movieId, r_ui=true_rating, est=pred_rating,details={'was_impossible': False}))
      return estimations

"""## Task 6: evaluate algotihms and fill in metric_report (10 points, -0.5 for each entry if error > 0.002)
In this task, you will evaluate Surprise's four built-in algorithms with your FunkSVD, and stest 2 built-in metrics and your ndcg@5 and ILS@5 over those algorithms.

1) 9 algorithms:

from Surprise: bias(BaselineOnly), UserUser(KNNBasic), ItemItem(KNNBasic), NMF(NMF), SVD (from Surpriese, set n_factors=10, n_epochs=20); for KNNBasic, change sim_options to use UserUser or ItemItem

implemented by you: MyFunkSVD (k=10,15,20,25)

2) 4 metrics: rmse, mae, ndcg@5, intra-similarity@5

3) use the **my_split** (set random_state=2021) method above to implement 5-fold evaluation and report **the average scores of the 5 folds** in **metric_report** -- evaluate rmse and mae on **testset_rated**; evaluate ndcg and ILS on **testset_withunrated**

You will fill in the **metric_report** below, whose entry (algorithmm, metric) is the performance of the algorithm on that metric.

To check your result: ndcg of Bias is around 0.563~0.567.

This task might take 1 to 2 hours.




"""

from surprise import accuracy
from surprise import SVD
metric_report = pd.DataFrame(index=['Bias', 'UserUser','ItemItem','NMF', 'SVD', 'MyFunkSVD_10','MyFunkSVD_15','MyFunkSVD_20','MyFunkSVD_25'], columns=['rmse','mae','ndcg', 'intra_similarity'])

# use the built-in funk svd at one parameter
# Task 6 to do start: fill in metric_report
mylist = my_split(data)

userlist = []
movielist = []
for i in data.raw_ratings:
  if (i[0] not in userlist):
    userlist.append(i[0])
  if (i[1] not in movielist):
    movielist.append(i[1])
n_user = len(userlist)
n_movie = len(movielist)

sum = 0.0
def func(alg):
  global sum
  algo = alg
  algoAcc = []
  algo1Acc = []
  algo2Acc = []
  for i in mylist:
    trainset = i[0]
    testset = i[1]
    testset_2 = i[2]
    # Train the algorithm on the trainset, and predict ratings for the testset
    algo.fit(trainset)
    predictions = algo.test(testset)
    predictions_2 = algo.test(testset_2)
    algoAcc.append(accuracy.rmse(predictions, verbose=False))
    algo1Acc.append(accuracy.mae(predictions, verbose=False))
    sum += ndcg(predictions_2, n_user, n_movie)
    algo2Acc.append(intra_similarity(predictions_2))
  algoAve = 0
  algo1Ave = 0
  algo2Ave = 0
  algo3Ave = 0
  for j in algoAcc:
    algoAve += j
  for j in algo1Acc:
    algo1Ave += j
  sum = sum/5
  for j in algo2Acc:
    algo3Ave += j
  algoAve = algoAve/5
  algo1Ave = algo1Ave/5
  algo2Ave = sum
  algo3Ave = algo3Ave/5
  return algoAve, algo1Ave, algo2Ave

sim_options1 = {"user_based": True} #useruser
sim_options = {"user_based": False} #itemitem

algo = BaselineOnly()
algo1 = KNNBasic(sim_options=sim_options1)
algo2 = KNNBasic(sim_options=sim_options)
algo3 = NMF()
algo4 = SVD()
algo5 = MyFunkSVD(k=10)
algo6 = MyFunkSVD(k=15)
algo7 = MyFunkSVD(k=20)
algo8 = MyFunkSVD(k=25)

# rmse, mae, ndcg_val = func(algo)
# rmse1, mae1, ndcg1 = func(algo1)
# rmse2, mae2, ndcg2 = func(algo2)
# rmse3, mae3, ndcg3 = func(algo3)
# rmse4, mae4, ndcg4 = func(algo4)
# rmse5, mae5, ndcg5 = func(algo5)
# rmse6, mae6, ndcg6 = func(algo6)
# rmse7, mae7, ndcg7 = func(algo7)
# rmse8, mae8, ndcg8 = func(algo8)
rmse, mae, ndcg_val, ils_val = func(algo)
rmse1, mae1, ndcg1, ils_val1 = func(algo1)
rmse2, mae2, ndcg2, ils_val2 = func(algo2)
rmse3, mae3, ndcg3, ils_val3 = func(algo3)
rmse4, mae4, ndcg4, ils_val4 = func(algo4)
rmse5, mae5, ndcg5, ils_val5 = func(algo5)
rmse6, mae6, ndcg6, ils_val6 = func(algo6)
rmse7, mae7, ndcg7, ils_val7 = func(algo7)
rmse8, mae8, ndcg8, ils_val8 = func(algo8)

metric_report.iloc[0][0] = rmse
metric_report.iloc[1][0] = rmse1
metric_report.iloc[2][0] = rmse2
metric_report.iloc[3][0] = rmse3
metric_report.iloc[4][0] = rmse4
metric_report.iloc[5][0] = rmse5
metric_report.iloc[6][0] = rmse6
metric_report.iloc[7][0] = rmse7
metric_report.iloc[8][0] = rmse8
metric_report.iloc[0][1] = mae
metric_report.iloc[1][1] = mae1
metric_report.iloc[2][1] = mae2
metric_report.iloc[3][1] = mae3
metric_report.iloc[4][1] = mae4
metric_report.iloc[5][1] = mae5
metric_report.iloc[6][1] = mae6
metric_report.iloc[7][1] = mae7
metric_report.iloc[8][1] = mae8
metric_report.iloc[0][2] = ndcg_val
metric_report.iloc[1][2] = ndcg1
metric_report.iloc[2][2] = ndcg2
metric_report.iloc[3][2] = ndcg3
metric_report.iloc[4][2] = ndcg4
metric_report.iloc[5][2] = ndcg5
metric_report.iloc[6][2] = ndcg6
metric_report.iloc[7][2] = ndcg7
metric_report.iloc[8][2] = ndcg8
metric_report.iloc[0][3] = ils_val
metric_report.iloc[1][3] = ils_val1
metric_report.iloc[2][3] = ils_val2
metric_report.iloc[3][3] = ils_val3
metric_report.iloc[4][3] = ils_val4
metric_report.iloc[5][3] = ils_val5
metric_report.iloc[6][3] = ils_val6
metric_report.iloc[7][3] = ils_val7
metric_report.iloc[8][3] = ils_val8
# Task 6 to do end

mylist = my_split(data)
sum = 0.0
def func(alg):
  algo = alg
  algoAcc = []
  algo1Acc = []
  algo2Acc = []
  for i in mylist:
    trainset = i[0]
    testset = i[1]
    testset_2 = i[2]
    # Train the algorithm on the trainset, and predict ratings for the testset
    algo.fit(trainset)
    predictions = algo.test(testset)
    predictions_2 = algo.test(testset_2)
    algoAcc.append(accuracy.rmse(predictions, verbose=False))
    algo1Acc.append(accuracy.mae(predictions, verbose=False))
    sum += ndcg(predictions_2, n_user, n_movie)
    # algo2Acc.append(intra_similarity(predictions_2))
  algoAve = 0
  algo1Ave = 0
  algo2Ave = 0
  algo3Ave = 0
  for j in algoAcc:
    algoAve += j
  for j in algo1Acc:
    algo1Ave += j
  sum = sum/5
  # for j in algo2Acc:
  #   algo3Ave += j
  algoAve = algoAve/5
  algo1Ave = algo1Ave/5
  algo2Ave = sum
  # algo3Ave = algo3Ave/5
  return algoAve, algo1Ave, algo2Ave

algo5 = MyFunkSVD(k=10)
rmse, mae, ndcg_val = func(algo5)

print(algo5.predict_ratings)

print(metric_report)#-6 metric_report incomplete

"""## Task 7: answer the following questions in this cell.
1) Analyze the algorithms' performance. Identify two algorithms that you feel could be best for https://movielens.org/ on the top picks page and on the rate more page.  Explain why you feel these algorithms best suit those uses. (5 points)



2) Does your funksvd perform well? Read this page https://surprise.readthedocs.io/en/stable/matrix_factorization.html, what could you do to improve your funksvd algorithm? (5 points)

1. SVD and Bias as they have the lowest RMSE and MAE and this is important because they measure the error values and they also have the highest intra list similarity. Their ndcg scores are also good and as this measures the relevance of each item to the user, this is very important for movie recommendations. Although user user has a higher ndcg value than Bias, it has a higher RMSE and MAE and this tradeoff seems worth it.

2. Unfortunately, MyFunkSVD doesn't show any results and I am not sure if it performs well. But my logic is correct, so I do not see why it is not displaying any results. In terms of improving the algorithm, messing with the number of epochs and the number of factors could potentially improve the algorithm as increasing either of these values could make the algorithm more "complex".
"""